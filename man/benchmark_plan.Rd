% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/benchmark_plan.R
\name{benchmark_plan}
\alias{benchmark_plan}
\title{Benchmark an Expression Across Future Backends}
\usage{
benchmark_plan(
  expr,
  types = c("sequential", "multicore", "multisession"),
  cores = slurm_cores(),
  times = 1L,
  auto_detect = FALSE,
  vary_cores = FALSE
)
}
\arguments{
\item{expr}{An expression to benchmark (unquoted).}

\item{types}{Character vector of backend types to test. Defaults to
\code{c("sequential", "multicore", "multisession")}. Ignored when
\code{auto_detect = TRUE}.}

\item{cores}{Integer number of workers for parallel backends. Defaults to
\code{\link[=slurm_cores]{slurm_cores()}}.}

\item{times}{Integer number of repetitions per backend. Default is \code{1}.}

\item{auto_detect}{Logical. If \code{TRUE}, automatically discovers all
installed backends and benchmarks each one. Default \code{FALSE}.}

\item{vary_cores}{Logical. If \code{TRUE}, tests multiple worker counts
for each parallel backend (half, N-1, and N cores). Default \code{FALSE}.}
}
\value{
A data frame with columns \code{type}, \code{cores}, \code{rep}, \code{elapsed}
(seconds), \code{speedup} (relative to sequential), and \code{efficiency}
(percent: speedup / cores * 100). Returned invisibly; a formatted
summary with a recommendation is printed.
}
\description{
Runs \code{expr} under each specified backend and returns timings with
speedup and efficiency metrics. Useful for choosing the fastest
backend and optimal core count for a given workload.
}
\examples{
\dontrun{
# Basic comparison
benchmark_plan(
  Reduce("+", future.apply::future_lapply(1:200, function(x) rnorm(1e4))),
  types = c("sequential", "multicore", "multisession"),
  cores = 4
)

# Auto-detect all installed backends and vary core counts
benchmark_plan(
  Reduce("+", future.apply::future_lapply(1:200, function(x) rnorm(1e4))),
  auto_detect = TRUE,
  vary_cores = TRUE
)
}
}
