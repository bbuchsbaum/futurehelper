% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/with_parallel.R
\name{with_parallel}
\alias{with_parallel}
\title{Evaluate an Expression with Automatic Parallel Setup}
\usage{
with_parallel(
  expr,
  cores = slurm_cores(),
  mem = 4,
  type = "multicore",
  nested = FALSE
)
}
\arguments{
\item{expr}{An expression to evaluate under the parallel plan.}

\item{cores}{Integer number of workers. Defaults to \code{\link[=slurm_cores]{slurm_cores()}}.}

\item{mem}{Numeric memory limit in GiB. Default \code{4}.}

\item{type}{Character backend type (see \code{\link[=init_future]{init_future()}}). Default
\code{"multicore"}.}

\item{nested}{Logical. If \code{TRUE}, uses a nested plan. Default \code{FALSE}.}
}
\value{
The result of evaluating \code{expr}.
}
\description{
A high-level convenience wrapper that initializes a parallel
\code{\link[future:plan]{future::plan()}}, evaluates \code{expr}, and restores the previous plan on exit
(even on error). Unlike \code{\link[=with_plan]{with_plan()}}, which requires a plan function, this
takes simple parameters like \code{cores} and \code{type} directly --- no need to
separately call \code{\link[=init_future]{init_future()}} + your code + \code{\link[=reset_future]{reset_future()}}.
}
\examples{
\dontrun{
# Parallel lapply with 4 cores --- one line, done
result <- with_parallel(
  future.apply::future_lapply(1:100, function(x) x^2),
  cores = 4
)

# Use callr backend with 8 GiB memory limit
result <- with_parallel(
  future.apply::future_sapply(big_list, process_fn),
  cores = 8, mem = 8, type = "callr"
)

# The plan is always restored afterward, even on error
future::plan(future::sequential)
with_parallel(long_computation(), cores = 4)
# back to sequential here
}
}
\seealso{
\code{\link[=with_plan]{with_plan()}} for the lower-level interface that takes a plan
function directly, \code{\link[=init_future]{init_future()}} for persistent plan setup.
}
